hint => The Name of Authentication Header is  Authorization

									~!  Difference Beween < Authentication > and < Authorization >   !~

Authentication => Getting User's Identity

Authorization  => Getting User's Permissions

											~! Difference Between <Token> and <session> !~

														<Token>
    Token or JWT => Mean JSON Web Token is a =>	 proposed Internet standard for creating data with optional signature 
	and/or optional encryption whose payload holds JSON that asserts some number of claims. The tokens are signed
	either using a private secret or a public/private key.
													or
	A token is an authorization file that cannot be tampered with. It is generated by the server using a secret key, sent to 
	and stored by the user in their local storage. Like in the case of cookies, the user sends this token to the server with 
	every new request, so that the server can verify its signature and authorize the requests. 

Working:
    1-The user sends a login request to the server.
    2-The server authorizes the login and sends a token to the user.
    3-Now, the user sends a new request(with a token).
    4-The server checks the token is valid or not, if the token is valid it sends the requested pages to the user.

EX:
	a server could generate a token that has the claim "logged in as administrator" and provide that to a client.
	The client could then use that token to prove that it is logged in as administrator
Structure:
	Header:
		{
		  "alg": "HS256",
		  "typ": "JWT"
		}
	Payload:
		{
		  "loggedInAs": "admin",
		  "iat": 1422779638
		}
	Signature:
		HMAC_SHA256(
		  secret,
		  base64urlEncoding(header) + '.' +
		  base64urlEncoding(payload)
		)
													 <session>
		   is a small file, most likely in JSON format, that stores information about the user, such as a unique ID, time of 
		   login and expirations, and so on. It is generated and stored on the server so that the server can keep track of 
		   the user requests. The user receives some of these details, especially the ID, as coo

Working:
    1-The user sends a login request to the server.
    2-The server authenticates the login request, sends a session to the database, and returns a cookie containing the session ID to the user.
    3-Now, the user sends new requests (with a cookie).
    4-The server checks in the database for the ID found in the cookie, if the ID is found it sends the requested pages to the user.
 
 													Conclusion
    1-Session and token-based are two authentication methods that allow a server to trust all the requests it receives from 
    a user. The main difference is session-based authentication of the connection stores the authentication details. The 
    session method makes the server store most of the details, while in the case of the token-based one the client stores 
    them.
    2-The session authentication method is based on the concept of the ID being shared with the client through a cookie 
    file, while the rest of the details are on the session file, stored on the server.
    3-The token-based authentication method is based on the concept that possessing a token is the only thing that a user 
    needs to have their requests authorized by the server, which must only verify a signature. The token is secure to use 
    because it cannot be tampered with.
    4-Both methods have inherent vulnerabilities that can be most easily resolved with different workarounds. In the end, 
    developers must decide which method suits better to their needs and applications.

=============================================================================================================================
												*<	Brute-force attacks  >*

Username enumeration:
			Username enumeration typically occurs either on the login page, for example, when you enter a valid username but 
			an incorrect password, or on registration forms when you enter a username that is already taken. This greatly 
			reduces the time and effort required to brute-force a login because the attacker is able to quickly generate a 
			shortlist of valid usernames. 
While attempting to brute-force a login page, you should pay particular attention to any differences in: 
			1.Status codes	: During a brute-force attack, the returned HTTP status code is likely to be the same for the 
							  vast majority of guesses because most of them will be wrong. If a guess returns a different 
							  status code, this is a strong indication that the username was correct. It is best practice 
							  for websites to always return the same status code regardless of the outcome, but this 
							  practice is not always followed. 
								  Usage Burpsuite:
								  		 1-With Burp running, investigate the login page and submit an invalid username and password.
										 2-In Burp, go to Proxy > HTTP history and find the POST /login request. Send this to Burp 
										   Intruder.
										 3-In Burp Intruder, go to the Positions tab. Make sure that the Sniper attack type is 
										   selected.
										 4-Click Clear § to remove any automatically assigned payload positions. Highlight the value 
										   of the username parameter and click Add § to set it as a payload position. This position 
										   will be indicated by two § symbols, for example: username=§invalid-username§. Leave the 
										   password as any static value for now.
										 5-On the Payloads tab, make sure that the Simple list payload type is selected.
										 6-Under Payload options, paste the list of candidate usernames. Finally, click Start attack. 
										   The attack will start in a new window.
										 7-When the attack is finished, on the Results tab, examine the Length column. You can click 
										   on the column header to sort the results. Notice that one of the entries is longer than 
										   the others. Compare the response to this payload with the other responses. Notice that 
										   other responses contain the message Invalid username, but this response says Incorrect 
										   password. Make a note of the username in the Payload column.

										 8-Close the attack and go back to the Positions tab. Click Clear, then change the username 
										   parameter to the username you just identified. Add a payload position to the password 
										   parameter. The result should look something like this:
										 9-username=identified-user&password=§invalid-password§
										 10-On the Payloads tab, clear the list of usernames and replace it with the list of  
										   candidate passwords. Click Start attack.
										 11-When the attack is finished, look at the Status column. Notice that each request received 
										   a response with a 200 status code except for one, which got a 302 response. This suggests 
										   that the login attempt was successful - make a note of the password in the Payload column.

										 12-Log in using the username and password that you identified and access the user account 
										   page to solve the lab. 
					
			2.Error messages: Sometimes the returned error message is different depending on whether both the username AND 
							  password are incorrect or only the password was incorrect. It is best practice for websites 
							  to use identical, generic messages in both cases, but small typing errors sometimes creep in. 
							  Just one character out of place makes the two messages distinct, even in cases where the 
							  character is not visible on the rendered page. 
		     					  Usage Burpsuite:
								  		 1-With Burp running, submit an invalid username and password. Send the POST /login request 
								  		   to Burp Intruder and add a payload position to the username parameter.
										 2-On the Payloads tab, make sure that the Simple list payload type is selected and add the 
										   list of candidate usernames.
										 3-On the Options tab, under Grep - Extract, click Add. In the dialog that appears, scroll 
										   down through the response until you find the error message Invalid username or password.. 
										   Use the mouse to highlight the text content of the message. The other settings will be 
										   automatically adjusted. Click OK and then start the attack.
										 4-When the attack is finished, notice that there is an additional column containing the 
										   error message you extracted. Sort the results using this column to notice that one of them 
										   is subtly different.
										 5-Look closer at this response and notice that it contains a typo in the error message - 
										   instead of a full stop/period, there is a trailing space. Make a note of this username.
										 6-Close the attack and go back to the Positions tab. Insert the username you just identified 
										   and add a payload position to the password parameter:
										 7-username=identified-user&password=§invalid-password§
										 8-On the Payloads tab, clear the list of usernames and replace it with the list of 
										   passwords. Start the attack.
										 9-When the attack is finished, notice that one of the requests received a 302 response. Make 
										   a note of this password.
										 10-Log in using the username and password that you identified and access the user account 
										   page to solve the lab. 
								
			3.Response times:  If most of the requests were handled with a similar response time, any that deviate from 
							   this suggest that something different was happening behind the scenes. This is another 
							   indication that the guessed username might be correct. For example, a website might only 
							   check whether the password is correct if the username is valid. This extra step might cause 
							   a slight increase in the response time. This may be subtle, but an attacker can make this 
							   delay more obvious by entering an excessively long password that the website takes 
							   noticeably longer to handle. 
		     					  Usage Burpsuite:
								  		Intruder=>
								  			 1-With Burp running, submit an invalid username and password, then send the POST /login
								  			   request to Burp Repeater. Experiment with different usernames and passwords. Notice 
								  			   that your IP will be blocked if you make too many invalid login attempts.
											 2-Identify that the X-Forwarded-For header is supported, which allows you to spoof your 
											   IP address and bypass the IP-based brute-force protection.
											 3-Continue experimenting with usernames and passwords. Pay particular attention to the 
											   response times. Notice that when the username is invalid, the response time is roughly 
											   the same. However, when you enter a valid username (your own), the response time is 
											   increased depending on the length of the password you entered.
											 4-Send this request to Burp Intruder and select the attack type to Pitchfork. Clear the 
											   default payload positions and add the X-Forwarded-For header.
											 5-Add payload positions for the X-Forwarded-For header and the username parameter. Set 
											   the password to a very long string of characters (about 100 characters should do it).
											 6-On the Payloads tab, select payload set 1. Select the Numbers payload type. Enter the 
											   range 1 - 100 and set the step to 1. Set the max fraction digits to 0. This will be 
											   used to spoof your IP.
											 7-Select payload set 2 and add the list of usernames. Start the attack.
											 8-When the attack finishes, at the top of the dialog, click Columns and select the 
											   Response received and Response completed options. These two columns are now displayed 
											   in the results table.
											 9-Notice that one of the response times was significantly longer than the others. Repeat 
											   this request a few times to make sure it consistently takes longer, then make a note 
											   of this username.
											 10-Create a new Burp Intruder attack for the same request. Add the X-Forwarded-For 
											   header again and add a payload position to it. Insert the username that you just 
											   identified and add a payload position to the password parameter.
											 11-On the Payloads tab, add the list of numbers in payload set 1 and add the list of 
											   passwords to payload set 2. Start the attack.
											 12-When the attack is finished, find the response with a 302 status. Make a note of this 
											   password.
											 13-Log in using the username and password that you identified and access the user 
											   account page to solve the lab. 


the type of broken authentication:
		1) Vulnerabilities in password-based login
					1.Username enumeration via different responses
					2.Username enumeration via subtly different responses
					3.Username enumeration via response timing
					4.Broken brute-force protection, IP block
					5.Username enumeration via account lock
					6.Broken brute-force protection, multiple credentials per request
		2) Vulnerabilities in multi-factor authentication 
 



finally don't forget read some reports about authnetication:
	search like : hackerone  Authentication reports

